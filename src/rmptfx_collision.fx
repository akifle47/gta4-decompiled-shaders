#define NO_LUMINANCE_CONSTANTS
#define NO_LIGHTING
#define NO_SHADOW_CASTING
#define PAD_LIGHT_CONSTANTS
#define USE_GENERATED_VS_BLIT

#include "common.fxh"
#include "megashader.fxh"

shared float4x4 gCameraMatrix : CameraMatrix;
shared float4 gShadowmap_ShadowColor0 : Shadowmap_ShadowColor0 = float4(1.0, 1.0, 1.0, 0.723000);
shared float4 gShadowmap_PixelSize0 : Shadowmap_PixelSize0;
shared float gGeometryScale : GeometryScale;
shared float2 gShadowCollectorTexelSize : ShadowCollectorTexelSize;
shared float3 gPointLightPosition : PointLightPosition;
shared float gPointLightAttenuation : PointLightAttenuation;
shared float gLightAttenuationEnd : LightAttenuationEnd;
shared texture DepthTexture0;
shared sampler DepthTextureSampler0 : register(s15) = 
sampler_state
{
    Texture = <DepthTexture0>;
    AddressU = CLAMP;
    AddressV = CLAMP;
    AddressW = CLAMP;
    MipFilter = NONE;
    MinFilter = ANISOTROPIC;
    MagFilter = ANISOTROPIC;
    MipMapLodBias = 16.000000;
};
shared texture CubeShadowMap;
shared sampler CubeShadowMapSampler = 
sampler_state
{
    Texture = <CubeShadowMap>;
    AddressU = CLAMP;
    AddressV = CLAMP;
    AddressW = CLAMP;
    MipFilter = NONE;
    MinFilter = POINT;
    MagFilter = POINT;
};
shared texture ShadowCollectorTex;
shared sampler ShadowCollectorSampler = 
sampler_state
{
    Texture = <ShadowCollectorTex>;
    AddressU = WRAP;
    AddressV = WRAP;
    AddressW = WRAP;
    MipFilter = NONE;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

texture AmbientOccTex;
sampler AmbientOccSampler = 
sampler_state
{
    Texture = <AmbientOccTex>;
    AddressU = WRAP;
    AddressV = WRAP;
    AddressW = WRAP;
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipMapLodBias = 0.000000;
};
texture LightOcclusionTex;
sampler LightOcclusionSampler = 
sampler_state
{
    Texture = <LightOcclusionTex>;
    AddressU = WRAP;
    AddressV = WRAP;
    AddressW = WRAP;
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipMapLodBias = 0.000000;
};
texture PRTOccTex;
sampler PRTOccSampler = 
sampler_state
{
    Texture = <PRTOccTex>;
    AddressU = WRAP;
    AddressV = WRAP;
    AddressW = WRAP;
    MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipMapLodBias = 0.000000;
};
float3 ClipPlanes : ClipPlanes;

//Vertex shaders
VertexShader VS_Transform
<
    string gWorldViewProj = "parameter register(8)";
> =
asm
{
    //
    // Generated by Microsoft (R) HLSL Shader Compiler 9.26.952.2844
    //
    // Parameters:
    //
    //   row_major float4x4 gWorldViewProj;
    //
    //
    // Registers:
    //
    //   Name           Reg   Size
    //   -------------- ----- ----
    //   gWorldViewProj c8       4
    //
    
        vs_3_0
        dcl_position v0
        dcl_normal v1
        dcl_position o0
        dcl_texcoord1 o1.xyz
        dcl_texcoord o2.x
        mul r0.xyz, c9, v1.y
        mad r0.xyz, v1.x, c8, r0
        mad o1.xyz, v1.z, c10, r0
        mul r0, c9, v0.y
        mad r0, v0.x, c8, r0
        mad r0, v0.z, c10, r0
        add r0, r0, c11
        rcp r1.x, r0.w
        mul o2.x, r0.z, r1.x
        mov o0, r0
    
    // approximately 10 instruction slots used
};

VertexShader VS_TransformSkin
<
    string gBoneMtx       = "parameter register(64)";
    string gWorldViewProj = "parameter register(8)";
> =
asm
{
    //
    // Generated by Microsoft (R) HLSL Shader Compiler 9.26.952.2844
    //
    // Parameters:
    //
    //   row_major float3x4 gBoneMtx[48];
    //   row_major float4x4 gWorldViewProj;
    //
    //
    // Registers:
    //
    //   Name           Reg   Size
    //   -------------- ----- ----
    //   gWorldViewProj c8       4
    //   gBoneMtx       c64    144
    //
    
        vs_3_0
        def c0, 765.005859, 1, 0, 0
        dcl_position v0
        dcl_blendweight v1
        dcl_blendindices v2
        dcl_normal v3
        dcl_position o0
        dcl_texcoord1 o1.xyz
        dcl_texcoord o2.x
        mul r0, c0.x, v2
        mova a0, r0
        mul r0, v1.y, c65[a0.y]
        mad r0, c65[a0.x], v1.x, r0
        mad r0, c65[a0.z], v1.z, r0
        mad r0, c65[a0.w], v1.w, r0
        dp3 r1.x, r0, v3
        mul r1.xyz, r1.x, c9
        mul r2, v1.y, c64[a0.y]
        mad r2, c64[a0.x], v1.x, r2
        mad r2, c64[a0.z], v1.z, r2
        mad r2, c64[a0.w], v1.w, r2
        dp3 r1.w, r2, v3
        mad r1.xyz, r1.w, c8, r1
        mul r3, v1.y, c66[a0.y]
        mad r3, c66[a0.x], v1.x, r3
        mad r3, c66[a0.z], v1.z, r3
        mad r3, c66[a0.w], v1.w, r3
        dp3 r1.w, r3, v3
        mad o1.xyz, r1.w, c10, r1
        mad r1, v0.xyzx, c0.yyyz, c0.zzzy
        dp4 r0.x, r0, r1
        mul r0, r0.x, c9
        dp4 r2.x, r2, r1
        dp4 r1.x, r3, r1
        mad r0, r2.x, c8, r0
        mad r0, r1.x, c10, r0
        add r0, r0, c11
        rcp r1.x, r0.w
        mul o2.x, r0.z, r1.x
        mov o0, r0
    
    // approximately 31 instruction slots used
};

//this outputs a color and 3 texture coordinates but all of the pixel shaders that use its output only use the texture coordinate so i replaced all
//the techniques that use it with the megashader VS_Blit for less code duplication and potentially 1 less microsecond per frame
/*
VertexShader VS_Blit
<
> =
asm
{
    //
    // Generated by Microsoft (R) HLSL Shader Compiler 9.26.952.2844
        vs_3_0
        def c0, 1, 0, -1, 0
        dcl_position v0
        dcl_color v1
        dcl_texcoord v2
        dcl_texcoord1 v3
        dcl_position o0
        dcl_color o1
        dcl_texcoord o2.xy
        dcl_texcoord1 o3.xy
        dcl_texcoord2 o4.xyz
        mad o0, v0.xyzx, c0.xxxy, c0.yyyx
        mov o1, v1
        mov o2.xy, v2
        mov o3.xy, v3
        mov o4.xyz, c0.yyzw
    
    // approximately 5 instruction slots used
};
*/

PixelShader PixelShader0 = NULL;

PixelShader PS_Draw
<
> =
asm
{
    //
    // Generated by Microsoft (R) HLSL Shader Compiler 9.26.952.2844
        ps_3_0
        def c0, 0.5, 0, 1, 0
        dcl_texcoord1 v0.xyz
        mad oC0, v0.xyzx, c0.xxxy, c0.xxxz
    
    // approximately 1 instruction slot used
};

PixelShader PS_CopyDepth
<
    string DepthTextureSampler0 = "parameter register(15)";
> =
asm
{
    //
    // Generated by Microsoft (R) HLSL Shader Compiler 9.26.952.2844
    //
    // Parameters:
    //
    //   sampler2D DepthTextureSampler0;
    //
    //
    // Registers:
    //
    //   Name                 Reg   Size
    //   -------------------- ----- ----
    //   DepthTextureSampler0 s15      1
    //
    
        ps_3_0
        dcl_texcoord v0.xy
        dcl_2d s15
        texld oC0, v0, s15
    
    // approximately 1 instruction slot used (1 texture, 0 arithmetic)
};

technique draw
{
    pass p0
    {
        AlphaBlendEnable = false;
        AlphaTestEnable = false;
        CullMode = CCW;
        ZEnable = true;
        ZWriteEnable = true;

        VertexShader = VS_Transform;
        PixelShader = PS_Draw;
    }
}

technique drawskinned
{
    pass p0
    {
        AlphaBlendEnable = false;
        AlphaTestEnable = false;
        CullMode = CCW;
        ZEnable = true;
        ZWriteEnable = true;

        VertexShader = VS_TransformSkin;
        PixelShader = PS_Draw;
    }
}

technique CopyRT
{
    pass p0
    {
        CullMode = NONE;
        ZEnable = false;
        ZWriteEnable = false;
        AlphaBlendEnable = false;
        AlphaTestEnable = false;

        VertexShader = compile vs_3_0 VS_Blit();
        PixelShader = PS_CopyDepth;
    }
}

